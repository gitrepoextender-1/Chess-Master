<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chess Master</title>
    <!-- Load Tailwind CSS for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --light-square: #f0d9b5; /* Beige */
            --dark-square: #b58863; /* Brown */
            --selected-square: #64b5f6; /* Light Blue */
            --potential-move: rgba(0, 0, 0, 0.2); /* Semi-transparent circle */
            --font-inter: 'Inter', sans-serif;
        }
        body {
            font-family: var(--font-inter);
            background-color: #1f2937; /* Dark Gray background */
        }
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 90vmin; /* Responsive size */
            height: 90vmin;
            max-width: 600px;
            max-height: 600px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            overflow: hidden;
            touch-action: manipulation; /* Prevents unwanted scrolling on mobile */
        }
        .square {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 5vmin;
            cursor: pointer;
            position: relative;
            transition: background-color 0.15s ease-out;
            user-select: none;
        }
        .square.light { background-color: var(--light-square); }
        .square.dark { background-color: var(--dark-square); }
        .square.selected { background-color: var(--selected-square); }

        /* Piece Styling */
        .piece {
            font-size: clamp(30px, 6vmin, 60px);
            line-height: 1;
            transition: transform 0.1s;
            user-select: none;
            /* Use a bold/heavy font weight for better symbol rendering */
            font-weight: 900;
        }
        .white { color: #f9f9f9; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        .black { color: #333333; text-shadow: 1px 1px 2px rgba(255,255,255,0.5); }

        /* Potential Move Indicator (Dot) */
        .potential-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            border-radius: 50%;
            background-color: var(--potential-move);
            pointer-events: none; /* Allows click to pass through to the square */
            z-index: 10;
        }

        /* Capture Indicator (Thicker border) */
        .potential-capture {
            box-shadow: inset 0 0 0 4px #e53935; /* Red border */
            border-radius: 8px; /* Slight rounding for effect */
        }

        #status-message {
            min-height: 4rem;
        }

        /* Promotion Modal Styling */
        .promotion-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.3s;
        }
        .promotion-options {
            background: #2d3748; /* Darker blue-gray */
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
        }
        .promotion-option {
            padding: 0.5rem 1rem;
            margin: 0.5rem;
            border: 2px solid #667eea;
            background: #4a5568;
            color: white;
            cursor: pointer;
            border-radius: 6px;
            font-size: 2rem;
            transition: background 0.2s, transform 0.1s;
        }
        .promotion-option:hover {
            background: #667eea;
            transform: scale(1.05);
        }

    </style>
</head>
<body class="p-4 flex flex-col items-center justify-start min-h-screen">

    <h1 class="text-3xl font-extrabold text-white mb-4 mt-2">AI Chess Master</h1>

    <div id="status-message" class="text-xl font-semibold text-center rounded-lg p-3 mb-6 w-full max-w-md bg-gray-700 text-yellow-300 shadow-md">
        Player's Turn (White)
    </div>

    <div class="chess-board" id="chess-board">
        <!-- Squares generated by JavaScript -->
    </div>

    <div class="mt-8 flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4 w-full max-w-md">
        <button id="reset-button" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-xl transition duration-200">
            Restart Game
        </button>
        <select id="ai-difficulty" class="flex-1 bg-gray-600 text-white p-3 rounded-lg shadow-xl focus:ring-2 focus:ring-blue-400">
            <option value="2">AI Difficulty: Easy (Depth 2)</option>
            <option value="3" selected>AI Difficulty: Medium (Depth 3)</option>
            <option value="4">AI Difficulty: Hard (Depth 4)</option>
        </select>
    </div>

    <!-- Promotion Modal -->
    <div id="promotion-modal" class="promotion-modal hidden" aria-modal="true" role="dialog">
        <div class="promotion-options text-center">
            <h2 class="text-white text-2xl font-bold mb-4">Pawn Promotion!</h2>
            <p class="text-gray-400 mb-6">Choose a piece:</p>
            <div id="promotion-buttons" class="flex justify-center">
                <!-- Buttons will be populated here -->
            </div>
        </div>
    </div>

    <div id="move-history" class="mt-8 p-4 bg-gray-800 text-gray-200 rounded-lg shadow-lg w-full max-w-md h-32 overflow-y-auto">
        <h3 class="font-bold text-lg mb-2 text-blue-400">Move History (PGN)</h3>
        <p id="pgn-output" class="text-sm"></p>
    </div>

<script>
    // ====================================================================================
    // 1. CHESS ENGINE CORE - Constants, Piece Definitions, and Board Setup
    // ====================================================================================

    // Piece definitions using Unicode
    const PIECES = {
        'K': { code: '♔', value: 1000, color: 'white' },
        'Q': { code: '♕', value: 9, color: 'white' },
        'R': { code: '♖', value: 5, color: 'white' },
        'B': { code: '♗', value: 3.2, color: 'white' },
        'N': { code: '♘', value: 3, color: 'white' },
        'P': { code: '♙', value: 1, color: 'white' },
        'k': { code: '♚', value: -1000, color: 'black' },
        'q': { code: '♛', value: -9, color: 'black' },
        'r': { code: '♜', value: -5, color: 'black' },
        'b': { code: '♝', value: -3.2, color: 'black' },
        'n': { code: '♞', value: -3, color: 'black' },
        'p': { code: '♟', value: -1, color: 'black' },
        '.': { code: '', value: 0, color: 'empty' }
    };

    // Initial FEN string for a standard game
    const STARTING_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

    // Global game state object
    let GameState = {
        board: [],          // 8x8 array of piece characters
        turn: 'w',          // 'w' or 'b'
        castling: 'KQkq',   // Castling rights
        enPassant: '-',     // En passant target square (e.g., 'a3')
        halfMoveClock: 0,   // For the fifty-move rule
        fullMoveNumber: 1,  // Game turn number
        selectedSquare: null, // [row, col] of selected piece
        possibleMoves: [],  // Array of valid moves from the selected square
        isGameOver: false,
        history: [], // For PGN
        aiDepth: 3,
        promotionPending: null, // {from: [r,c], to: [r,c], piece: 'P'}
    };

    // Directions for move generation (used by sliding pieces)
    const DIRECTIONS = [
        [0, 1], [0, -1], [1, 0], [-1, 0], // Rook/Queen (Horizontal/Vertical)
        [1, 1], [1, -1], [-1, 1], [-1, -1] // Bishop/Queen (Diagonal)
    ];
    const KNIGHT_MOVES = [
        [2, 1], [2, -1], [-2, 1], [-2, -1],
        [1, 2], [1, -2], [-1, 2], [-1, -2]
    ];

    /**
     * Converts a square name (e.g., 'a1') to [row, col] (e.g., [7, 0]).
     * Chess board rows are 8 to 1 (index 0 to 7) and cols a to h (index 0 to 7).
     * @param {string} sq Square name like 'e4'
     * @returns {number[]} [row, col]
     */
    function algebraicToCoord(sq) {
        if (sq === '-') return null;
        const col = sq.charCodeAt(0) - 'a'.charCodeAt(0);
        const row = 8 - parseInt(sq[1], 10);
        return [row, col];
    }

    /**
     * Converts coordinates [row, col] to a square name (e.g., 'e4').
     * @param {number[]} coord [row, col]
     * @returns {string} Square name like 'e4'
     */
    function coordToAlgebraic([r, c]) {
        if (r < 0 || r > 7 || c < 0 || c > 7) return null;
        const file = String.fromCharCode('a'.charCodeAt(0) + c);
        const rank = 8 - r;
        return file + rank;
    }

    /**
     * Parses a FEN string and sets up the game state.
     * @param {string} fen FEN string
     */
    function parseFEN(fen) {
        const parts = fen.split(' ');
        const [pieces, turn, castling, enPassant, halfMoveClock, fullMoveNumber] = parts;

        // 1. Setup Board
        const newBoard = Array(8).fill(0).map(() => Array(8).fill('.'));
        let r = 0, c = 0;
        for (const char of pieces) {
            if (char === '/') {
                r++;
                c = 0;
            } else if (/[1-8]/.test(char)) {
                c += parseInt(char, 10);
            } else {
                newBoard[r][c] = char;
                c++;
            }
        }
        GameState.board = newBoard;

        // 2. Other state
        GameState.turn = turn;
        GameState.castling = castling;
        GameState.enPassant = enPassant;
        GameState.halfMoveClock = parseInt(halfMoveClock, 10);
        GameState.fullMoveNumber = parseInt(fullMoveNumber, 10);
        GameState.isGameOver = false;
        GameState.selectedSquare = null;
        GameState.possibleMoves = [];
        GameState.promotionPending = null;
    }

    // ====================================================================================
    // 2. UI RENDERER
    // ====================================================================================

    const boardEl = document.getElementById('chess-board');
    const statusEl = document.getElementById('status-message');
    const pgnEl = document.getElementById('pgn-output');
    const promotionModal = document.getElementById('promotion-modal');
    const promotionButtons = document.getElementById('promotion-buttons');
    const difficultySelect = document.getElementById('ai-difficulty');

    /**
     * Renders the entire chess board and its pieces to the DOM.
     */
    function renderBoard() {
        boardEl.innerHTML = ''; // Clear board
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const squareEl = document.createElement('div');
                squareEl.className = 'square rounded-sm transition-all duration-100 ease-in-out';
                squareEl.dataset.row = r;
                squareEl.dataset.col = c;
                squareEl.id = `sq-${r}-${c}`;

                // Apply color
                const color = (r + c) % 2 === 0 ? 'light' : 'dark';
                squareEl.classList.add(color);

                // Add piece
                const pieceChar = GameState.board[r][c];
                if (pieceChar !== '.') {
                    const pieceData = PIECES[pieceChar];
                    const pieceEl = document.createElement('span');
                    pieceEl.className = `piece ${pieceData.color}`;
                    pieceEl.textContent = pieceData.code;
                    pieceEl.dataset.piece = pieceChar;
                    squareEl.appendChild(pieceEl);
                }

                // Add click listener
                squareEl.addEventListener('click', handleSquareClick);
                boardEl.appendChild(squareEl);
            }
        }
        updateUIState();
    }

    /**
     * Updates the UI based on the current GameState.
     */
    function updateUIState() {
        // 1. Highlight selected square
        document.querySelectorAll('.square').forEach(sq => {
            sq.classList.remove('selected', 'potential-move', 'potential-capture');
        });

        if (GameState.selectedSquare) {
            const [r, c] = GameState.selectedSquare;
            document.getElementById(`sq-${r}-${c}`).classList.add('selected');

            // 2. Highlight potential moves
            GameState.possibleMoves.forEach(move => {
                const [tr, tc] = move.to;
                const targetSquareEl = document.getElementById(`sq-${tr}-${tc}`);
                const targetPiece = GameState.board[tr][tc];

                if (targetPiece !== '.') {
                    targetSquareEl.classList.add('potential-capture');
                } else {
                    targetSquareEl.classList.add('potential-move');
                }
            });
        }

        // 3. Update Status
        if (GameState.isGameOver) {
            const result = isGameOver(GameState.board, GameState.turn, GameState.halfMoveClock);
            if (result.checkmate) {
                const winner = GameState.turn === 'w' ? 'Black' : 'White';
                statusEl.textContent = `Checkmate! ${winner} Wins!`;
                statusEl.classList.remove('text-yellow-300');
                statusEl.classList.add('bg-red-800', 'text-white');
            } else if (result.stalemate) {
                statusEl.textContent = "Stalemate! Game is a Draw.";
                statusEl.classList.remove('text-yellow-300');
                statusEl.classList.add('bg-blue-800', 'text-white');
            } else if (result.fiftyMove) {
                 statusEl.textContent = "Draw by Fifty-Move Rule.";
                statusEl.classList.remove('text-yellow-300');
                statusEl.classList.add('bg-blue-800', 'text-white');
            }
        } else {
            statusEl.textContent = `${GameState.turn === 'w' ? "Player (White)" : "AI (Black)"}'s Turn`;
            statusEl.classList.remove('bg-red-800', 'bg-blue-800', 'text-white');
            statusEl.classList.add('bg-gray-700', 'text-yellow-300');
        }

        // 4. Update PGN
        pgnEl.textContent = GameState.history.join(' ');
    }

    /**
     * Shows the pawn promotion modal.
     * @param {object} pendingMove The pending move data
     */
    function showPromotionModal(pendingMove) {
        GameState.promotionPending = pendingMove;
        promotionButtons.innerHTML = '';
        const pieces = GameState.turn === 'w' ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];

        pieces.forEach(pieceChar => {
            const btn = document.createElement('button');
            btn.className = 'promotion-option';
            btn.textContent = PIECES[pieceChar].code;
            btn.addEventListener('click', () => handlePromotion(pieceChar));
            promotionButtons.appendChild(btn);
        });

        promotionModal.classList.remove('hidden');
    }

    // ====================================================================================
    // 3. MOVE GENERATOR (The heart of the chess rules)
    // ====================================================================================

    /**
     * Generates all pseudo-legal moves for a given piece on the board.
     * @param {Array<Array<string>>} board 8x8 board array
     * @param {number} r Start row
     * @param {number} c Start column
     * @returns {Array<object>} List of moves {from: [r,c], to: [r2,c2], promotion: char?}
     */
    function generatePieceMoves(board, r, c) {
        const moves = [];
        const pieceChar = board[r][c];
        const isWhite = pieceChar === pieceChar.toUpperCase();
        const opponentColor = isWhite ? 'black' : 'white';
        const pieceType = pieceChar.toLowerCase();

        const isCoordValid = (r, c) => r >= 0 && r < 8 && c >= 0 && c < 8;
        const isTargetEmptyOrOpponent = (r, c) => {
            const target = board[r][c];
            if (target === '.') return true;
            return PIECES[target].color === opponentColor;
        };

        const addMove = (r2, c2, promotion = null) => moves.push({ from: [r, c], to: [r2, c2], promotion });

        switch (pieceType) {
            case 'p': // PAWN
                const dir = isWhite ? -1 : 1; // White moves up (r-1), Black moves down (r+1)
                const startRow = isWhite ? 6 : 1;
                const promRow = isWhite ? 0 : 7;

                // 1. Single Step Forward
                const r1 = r + dir;
                if (isCoordValid(r1, c) && board[r1][c] === '.') {
                    if (r1 === promRow) {
                        ['Q', 'R', 'B', 'N'].forEach(p => addMove(r1, c, isWhite ? p : p.toLowerCase()));
                    } else {
                        addMove(r1, c);
                    }
                    // 2. Double Step Forward
                    const r2 = r + 2 * dir;
                    if (r === startRow && isCoordValid(r2, c) && board[r2][c] === '.') {
                        addMove(r2, c);
                    }
                }

                // 3. Captures
                [-1, 1].forEach(colOffset => {
                    const c2 = c + colOffset;
                    if (isCoordValid(r1, c2)) {
                        const target = board[r1][c2];
                        // Normal capture
                        if (target !== '.' && PIECES[target].color === opponentColor) {
                            if (r1 === promRow) {
                                ['Q', 'R', 'B', 'N'].forEach(p => addMove(r1, c2, isWhite ? p : p.toLowerCase()));
                            } else {
                                addMove(r1, c2);
                            }
                        }
                        // En Passant capture
                        if (GameState.enPassant !== '-') {
                            const [ep_r, ep_c] = algebraicToCoord(GameState.enPassant);
                            if (r1 === ep_r && c2 === ep_c) {
                                addMove(r1, c2); // Special move, move logic handles the capture
                            }
                        }
                    }
                });
                break;

            case 'n': // KNIGHT
                KNIGHT_MOVES.forEach(([dr, dc]) => {
                    const r2 = r + dr;
                    const c2 = c + dc;
                    if (isCoordValid(r2, c2) && isTargetEmptyOrOpponent(r2, c2)) {
                        addMove(r2, c2);
                    }
                });
                break;

            case 'b': // BISHOP (Diagonal directions 4 to 7 in DIRECTIONS array)
            case 'r': // ROOK (Straight directions 0 to 3)
            case 'q': // QUEEN (All directions)
                const startDir = pieceType === 'r' ? 0 : (pieceType === 'b' ? 4 : 0);
                const endDir = pieceType === 'r' ? 4 : (pieceType === 'b' ? 8 : 8);

                for (let i = startDir; i < endDir; i++) {
                    const [dr, dc] = DIRECTIONS[i];
                    for (let step = 1; step < 8; step++) {
                        const r2 = r + dr * step;
                        const c2 = c + dc * step;

                        if (!isCoordValid(r2, c2)) break; // Out of bounds

                        const target = board[r2][c2];
                        const isOpponent = target !== '.' && PIECES[target].color === opponentColor;
                        const isEmpty = target === '.';

                        if (isEmpty) {
                            addMove(r2, c2);
                        } else if (isOpponent) {
                            addMove(r2, c2);
                            break; // Stop after capturing
                        } else {
                            break; // Blocked by own piece
                        }
                    }
                }
                break;

            case 'k': // KING
                for (let i = 0; i < 8; i++) {
                    const [dr, dc] = DIRECTIONS[i];
                    const r2 = r + dr;
                    const c2 = c + dc;
                    if (isCoordValid(r2, c2) && isTargetEmptyOrOpponent(r2, c2)) {
                        addMove(r2, c2);
                    }
                }

                // Castling
                if (pieceType === 'k' && r === (isWhite ? 7 : 0) && c === 4) {
                    const side = isWhite ? 'w' : 'b';
                    const castlingRights = GameState.castling;

                    // Kingside (short) castling
                    const kSide = isWhite ? 'K' : 'k';
                    if (castlingRights.includes(kSide) && board[r][5] === '.' && board[r][6] === '.') {
                        if (!isSquareAttacked(board, r, 4, opponentColor) &&
                            !isSquareAttacked(board, r, 5, opponentColor) &&
                            !isSquareAttacked(board, r, 6, opponentColor)) {
                            addMove(r, 6); // Move to g1/g8
                        }
                    }
                    // Queenside (long) castling
                    const qSide = isWhite ? 'Q' : 'q';
                    if (castlingRights.includes(qSide) && board[r][3] === '.' && board[r][2] === '.' && board[r][1] === '.') {
                        if (!isSquareAttacked(board, r, 4, opponentColor) &&
                            !isSquareAttacked(board, r, 3, opponentColor) &&
                            !isSquareAttacked(board, r, 2, opponentColor)) {
                            addMove(r, 2); // Move to c1/c8
                        }
                    }
                }
                break;
        }

        return moves;
    }

    /**
     * Determines if a given square is attacked by the opponent.
     * @param {Array<Array<string>>} board 8x8 board array
     * @param {number} r Row of the square to check
     * @param {number} c Column of the square to check
     * @param {string} attackerColor 'white' or 'black'
     * @returns {boolean} True if the square is attacked
     */
    function isSquareAttacked(board, r, c, attackerColor) {
        const isAttackerWhite = attackerColor === 'white';
        const attackerPieces = isAttackerWhite ? ['K', 'Q', 'R', 'B', 'N', 'P'] : ['k', 'q', 'r', 'b', 'n', 'p'];

        for (let r_s = 0; r_s < 8; r_s++) {
            for (let c_s = 0; c_s < 8; c_s++) {
                const piece = board[r_s][c_s];
                if (attackerPieces.includes(piece)) {
                    // Temporarily generate moves for the attacking piece
                    // We need a lightweight version that doesn't check for legality (check), only pseudo-legality
                    const pseudoMoves = generatePieceMoves(board, r_s, c_s).filter(m => !m.promotion);

                    for (const move of pseudoMoves) {
                        if (move.to[0] === r && move.to[1] === c) {
                            // Pawns need a special check, as their capturing moves are different from forward moves
                            if (piece.toLowerCase() === 'p') {
                                // Pawn attacks only diagonally
                                if (Math.abs(c_s - c) === 1) return true;
                            } else {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    /**
     * Finds the king's position for the given color.
     * @param {Array<Array<string>>} board 8x8 board array
     * @param {string} color 'w' or 'b'
     * @returns {number[] | null} [row, col] or null if not found
     */
    function findKing(board, color) {
        const kingChar = color === 'w' ? 'K' : 'k';
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (board[r][c] === kingChar) return [r, c];
            }
        }
        return null; // Should not happen in a valid game
    }

    /**
     * Checks if the current side's king is in check.
     * @param {Array<Array<string>>} board 8x8 board array
     * @param {string} color 'w' or 'b' (the side to check)
     * @returns {boolean} True if the king is in check
     */
    function isKingInCheck(board, color) {
        const kingPos = findKing(board, color);
        if (!kingPos) return false;
        const attackerColor = color === 'w' ? 'black' : 'white';
        return isSquareAttacked(board, kingPos[0], kingPos[1], attackerColor);
    }

    /**
     * Generates all legal moves for the current side by filtering pseudo-legal moves.
     * @param {Array<Array<string>>} board 8x8 board array
     * @param {string} turn 'w' or 'b'
     * @returns {Array<object>} List of legal moves
     */
    function generateLegalMoves(board, turn) {
        const legalMoves = [];
        const playerPieces = turn === 'w' ? 'KQRNBP' : 'kqrbnp';

        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const pieceChar = board[r][c];
                if (playerPieces.includes(pieceChar)) {
                    const pseudoMoves = generatePieceMoves(board, r, c);
                    for (const move of pseudoMoves) {
                        const nextState = makeMove(board, move);
                        if (!isKingInCheck(nextState.board, turn)) {
                            legalMoves.push(move);
                        }
                    }
                }
            }
        }
        return legalMoves;
    }

    /**
     * Executes a move on a given board state and returns the new board/state.
     * NOTE: This function does NOT mutate GameState, it returns a new state object.
     * @param {Array<Array<string>>} currentBoard
     * @param {object} move {from: [r,c], to: [r2,c2], promotion: char?}
     * @returns {object} { board: newBoard, enPassant: newEp, castling: newCastling, halfMoveClock: newHalfMove }
     */
    function makeMove(currentBoard, move) {
        const newBoard = currentBoard.map(row => [...row]); // Deep copy
        const [r1, c1] = move.from;
        const [r2, c2] = move.to;
        const pieceChar = newBoard[r1][c1];
        const pieceType = pieceChar.toLowerCase();
        const isWhite = pieceChar === pieceChar.toUpperCase();

        let newCastling = GameState.castling;
        let newEnPassant = '-';
        let newHalfMove = GameState.halfMoveClock;
        const isCapture = newBoard[r2][c2] !== '.';

        // 1. Move the piece
        newBoard[r2][c2] = move.promotion || pieceChar;
        newBoard[r1][c1] = '.';

        // 2. Special moves
        if (pieceType === 'p') {
            newHalfMove = 0; // Reset for pawn moves
            // En Passant target update
            if (Math.abs(r1 - r2) === 2) {
                newEnPassant = coordToAlgebraic([r1 + (isWhite ? -1 : 1), c1]);
            }
            // En Passant capture (remove the captured pawn)
            else if (isCapture && coordToAlgebraic(move.to) === GameState.enPassant) {
                const capturedPawnRow = isWhite ? r2 + 1 : r2 - 1;
                newBoard[capturedPawnRow][c2] = '.';
            }
        } else if (isCapture) {
            newHalfMove = 0; // Reset for captures
        } else {
            newHalfMove++;
        }

        // Castling (Rook movement)
        if (pieceType === 'k' && Math.abs(c1 - c2) === 2) {
            // Kingside (short)
            if (c2 === 6) {
                newBoard[r1][5] = newBoard[r1][7]; // Move Rook
                newBoard[r1][7] = '.';
            }
            // Queenside (long)
            else if (c2 === 2) {
                newBoard[r1][3] = newBoard[r1][0]; // Move Rook
                newBoard[r1][0] = '.';
            }
        }

        // 3. Castling rights update
        if (pieceChar === 'K') newCastling = newCastling.replace(/[KQ]/g, '');
        if (pieceChar === 'k') newCastling = newCastling.replace(/[kq]/g, '');
        if (pieceChar === 'R' && r1 === 7 && c1 === 7) newCastling = newCastling.replace('K', '');
        if (pieceChar === 'R' && r1 === 7 && c1 === 0) newCastling = newCastling.replace('Q', '');
        if (pieceChar === 'r' && r1 === 0 && c1 === 7) newCastling = newCastling.replace('k', '');
        if (pieceChar === 'r' && r1 === 0 && c1 === 0) newCastling = newCastling.replace('q', '');

        return {
            board: newBoard,
            enPassant: newEnPassant,
            castling: newCastling,
            halfMoveClock: newHalfMove
        };
    }

    /**
     * Checks for checkmate, stalemate, and draw conditions.
     * @param {Array<Array<string>>} board
     * @param {string} turn 'w' or 'b'
     * @param {number} halfMoveClock
     * @returns {object} {checkmate: bool, stalemate: bool, fiftyMove: bool}
     */
    function isGameOver(board, turn, halfMoveClock) {
        const legalMoves = generateLegalMoves(board, turn);
        const inCheck = isKingInCheck(board, turn);
        const hasMoves = legalMoves.length > 0;

        return {
            checkmate: inCheck && !hasMoves,
            stalemate: !inCheck && !hasMoves,
            fiftyMove: halfMoveClock >= 100
        };
    }

    // ====================================================================================
    // 4. USER INTERACTION & GAME FLOW
    // ====================================================================================

    /**
     * Main handler for user clicks on a square.
     */
    function handleSquareClick(event) {
        if (GameState.turn !== 'w' || GameState.isGameOver) return;

        const targetEl = event.currentTarget;
        const r = parseInt(targetEl.dataset.row);
        const c = parseInt(targetEl.dataset.col);
        const pieceChar = GameState.board[r][c];
        const isWhitePiece = pieceChar !== '.' && pieceChar === pieceChar.toUpperCase();

        if (GameState.selectedSquare === null) {
            // 1. SELECT PIECE
            if (isWhitePiece) {
                GameState.selectedSquare = [r, c];
                GameState.possibleMoves = generatePieceMoves(GameState.board, r, c)
                    .filter(move => {
                        // Filter by legality (does not result in check)
                        const nextState = makeMove(GameState.board, move);
                        return !isKingInCheck(nextState.board, 'w');
                    });
            }
        } else {
            const [r_from, c_from] = GameState.selectedSquare;
            const move = GameState.possibleMoves.find(m => m.to[0] === r && m.to[1] === c);

            if (move) {
                // 2. EXECUTE MOVE
                if (move.promotion) {
                    showPromotionModal(move);
                } else {
                    executeMove(move);
                    // AI will be called automatically after the player's move.
                }

            } else if (isWhitePiece && r === r_from && c === c_from) {
                // 3. DESELECT PIECE (Clicking the same piece)
                GameState.selectedSquare = null;
                GameState.possibleMoves = [];
            } else if (isWhitePiece) {
                // 4. CHANGE SELECTION (Clicking a different friendly piece)
                GameState.selectedSquare = [r, c];
                GameState.possibleMoves = generatePieceMoves(GameState.board, r, c)
                    .filter(move => {
                        const nextState = makeMove(GameState.board, move);
                        return !isKingInCheck(nextState.board, 'w');
                    });
            } else {
                // 5. DESELECT (Clicking an empty or opponent square not in possibleMoves)
                GameState.selectedSquare = null;
                GameState.possibleMoves = [];
            }
        }

        updateUIState();
    }

    /**
     * Handles the pawn promotion choice and completes the move.
     * @param {string} pieceChar The piece to promote to (e.g., 'Q' or 'q')
     */
    function handlePromotion(pieceChar) {
        if (GameState.promotionPending) {
            const move = GameState.promotionPending;
            move.promotion = pieceChar;
            executeMove(move);
            promotionModal.classList.add('hidden');
            GameState.promotionPending = null;
        }
    }

    /**
     * Updates the full GameState based on a completed move.
     * @param {object} move The move object
     */
    function executeMove(move) {
        if (GameState.isGameOver) return;

        const newState = makeMove(GameState.board, move);
        const pgnMove = move.promotion ? `${coordToAlgebraic(move.from)}${coordToAlgebraic(move.to)}=${move.promotion.toUpperCase()}` : coordToAlgebraic(move.from) + coordToAlgebraic(move.to); // Simplified PGN
        if (GameState.turn === 'w') GameState.history.push(`${GameState.fullMoveNumber}. ${pgnMove}`);
        else GameState.history[GameState.history.length - 1] += ` ${pgnMove}`;

        // Update global state
        GameState.board = newState.board;
        GameState.castling = newState.castling;
        GameState.enPassant = newState.enPassant;
        GameState.halfMoveClock = newState.halfMoveClock;

        if (GameState.turn === 'b') {
            GameState.fullMoveNumber++;
        }

        GameState.turn = GameState.turn === 'w' ? 'b' : 'w';
        GameState.selectedSquare = null;
        GameState.possibleMoves = [];

        // Check for game over
        const result = isGameOver(GameState.board, GameState.turn, GameState.halfMoveClock);
        if (result.checkmate || result.stalemate || result.fiftyMove) {
            GameState.isGameOver = true;
        }

        renderBoard();

        // If it's the AI's turn, trigger the AI move
        if (GameState.turn === 'b' && !GameState.isGameOver) {
            setTimeout(triggerAIMove, 500); // 0.5 sec delay for better UX
        }
    }

    // ====================================================================================
    // 5. AI ENGINE (Minimax with Alpha-Beta Pruning)
    // ====================================================================================

    /**
     * Evaluation function to assign a score to a board state.
     * Positive score favors White; negative favors Black.
     * @param {Array<Array<string>>} board 8x8 board array
     * @returns {number} The board score
     */
    function evaluateBoard(board) {
        let score = 0;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const pieceChar = board[r][c];
                if (pieceChar !== '.') {
                    score += PIECES[pieceChar].value;
                }
            }
        }
        // Material advantage is the main factor. More complex evaluation (positional, pawn structure)
        // is generally required for competitive play, but material is sufficient for a basic AI.

        // Example Positional Bonus (for Pawns) - encourages moving center pawns
        for (let r = 1; r < 7; r++) {
            for (let c = 1; c < 7; c++) {
                const pieceChar = board[r][c];
                if (pieceChar === 'P') score += 0.05 * (8 - r); // White Pawns push up
                if (pieceChar === 'p') score -= 0.05 * r;     // Black Pawns push down
            }
        }

        return score;
    }

    /**
     * Minimax algorithm with Alpha-Beta Pruning.
     * @param {Array<Array<string>>} board The current board state
     * @param {string} turn 'w' (maximizing) or 'b' (minimizing)
     * @param {number} depth How many moves deep to search
     * @param {number} alpha Alpha value for pruning (best value found so far for the maximizer)
     * @param {number} beta Beta value for pruning (best value found so far for the minimizer)
     * @param {object} gameState The full game state including castling/ep
     * @returns {number} The evaluation score for the board at this depth
     */
    function minimax(board, turn, depth, alpha, beta, gameState) {
        // Base Case: Depth is 0 or game is over (checkmate/stalemate)
        if (depth === 0) {
            return evaluateBoard(board);
        }

        const legalMoves = generateLegalMoves(board, turn);
        const gameOver = isGameOver(board, turn, gameState.halfMoveClock);

        if (gameOver.checkmate) {
            // Checkmate: return a very large/small score favoring the current winning side
            return turn === 'w' ? -Infinity : Infinity;
        }
        if (gameOver.stalemate || gameOver.fiftyMove) {
            return 0; // Draw
        }

        if (turn === 'w') { // Maximizing player (White)
            let maxEval = -Infinity;
            for (const move of legalMoves) {
                const newState = makeMove(board, move);
                const evaluation = minimax(newState.board, 'b', depth - 1, alpha, beta, newState);
                maxEval = Math.max(maxEval, evaluation);
                alpha = Math.max(alpha, evaluation);
                if (beta <= alpha) break; // Alpha-Beta Pruning
            }
            return maxEval;
        } else { // Minimizing player (Black/AI)
            let minEval = Infinity;
            for (const move of legalMoves) {
                // To properly handle the turn switch in the recursive call, we must swap the turn:
                // next turn is 'w', depth decreases
                const newState = makeMove(board, move);
                const evaluation = minimax(newState.board, 'w', depth - 1, alpha, beta, newState);
                minEval = Math.min(minEval, evaluation);
                beta = Math.min(beta, evaluation);
                if (beta <= alpha) break; // Alpha-Beta Pruning
            }
            return minEval;
        }
    }

    /**
     * Finds the best move for the AI using the Minimax algorithm.
     */
    function triggerAIMove() {
        // Simple loading indicator
        statusEl.textContent = `AI (Black) is thinking... (Depth ${GameState.aiDepth})`;
        statusEl.classList.add('bg-blue-600', 'text-white');

        // This should run quickly, but for deep searches, a Web Worker or non-blocking method is better.
        // For simplicity and single-file mandate, we run it synchronously.
        const startTime = performance.now();
        const bestMove = findBestAIMove(GameState.board, GameState.turn, GameState.aiDepth, GameState);
        const endTime = performance.now();
        console.log(`AI calculation took: ${(endTime - startTime).toFixed(2)}ms`);

        statusEl.classList.remove('bg-blue-600', 'text-white');

        if (bestMove) {
            executeMove(bestMove);
        } else {
            console.error("AI could not find a move. Game likely over.");
        }
    }

    /**
     * Iterates through all legal moves and uses Minimax to find the highest-scoring move.
     * @param {Array<Array<string>>} board
     * @param {string} turn 'b' (AI is always minimizing)
     * @param {number} depth
     * @param {object} gameState The current full game state
     * @returns {object|null} The best move object
     */
    function findBestAIMove(board, turn, depth, gameState) {
        const legalMoves = generateLegalMoves(board, turn);
        let bestMove = null;
        let minEval = Infinity; // AI is Black (minimizing)

        // Randomize the order of moves to introduce variety and avoid deterministic play
        legalMoves.sort(() => Math.random() - 0.5);

        for (const move of legalMoves) {
            const newState = makeMove(board, move);
            // Call minimax with opposite turn and decreased depth
            const evaluation = minimax(newState.board, 'w', depth - 1, -Infinity, Infinity, newState);

            if (evaluation < minEval) {
                minEval = evaluation;
                bestMove = move;
            }
        }
        return bestMove;
    }

    // ====================================================================================
    // 6. INITIALIZATION & EVENT LISTENERS
    // ====================================================================================

    function initializeGame() {
        parseFEN(STARTING_FEN);
        GameState.history = [];
        GameState.aiDepth = parseInt(difficultySelect.value);
        renderBoard();
        console.log("Game initialized. Player (White) to move.");
    }

    // Reset button
    document.getElementById('reset-button').addEventListener('click', initializeGame);

    // AI Difficulty change
    difficultySelect.addEventListener('change', (e) => {
        GameState.aiDepth = parseInt(e.target.value);
        if (GameState.turn === 'b' && !GameState.isGameOver) {
            // If AI is currently thinking, let it finish, but the next search will use the new depth
            // For simplicity, we just log the change.
            console.log(`AI depth set to ${GameState.aiDepth}`);
        }
    });

    // Start the game when the script loads
    window.onload = initializeGame;

</script>
</body>
</html>


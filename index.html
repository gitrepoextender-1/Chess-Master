<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chess Master</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Richer, darker color palette */
            --light-square: #eed299; /* Cream/Light Gold */
            --dark-square: #b88648; /* Dark Brown/Coffee */
            --selected-square: #98c6ff; /* Soft Blue for selection */
            --potential-move: rgba(0, 0, 0, 0.25); /* Darker semi-transparent dot */
            --font-inter: 'Inter', sans-serif;
        }
        body {
            font-family: var(--font-inter);
            background-color: #0d121c; /* Very Dark Blue/Black */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            min-height: 100vh;
        }
        .main-container {
            width: 100%;
            max-width: 900px; /* Maximize space for board and side panel */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        @media (min-width: 768px) {
            .main-container {
                flex-direction: row;
                align-items: flex-start;
                justify-content: center;
            }
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 95vw;
            height: 95vw;
            max-width: 500px;
            max-height: 500px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            overflow: hidden;
            touch-action: manipulation;
            border: 4px solid #f9f9f9;
        }
        .square {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            transition: background-color 0.15s ease-out;
            user-select: none;
        }
        .square.light { background-color: var(--light-square); }
        .square.dark { background-color: var(--dark-square); }
        .square.selected { background-color: var(--selected-square); }

        /* Piece Styling - Slightly larger and bolder */
        .piece {
            font-size: clamp(35px, 7vmin, 65px);
            line-height: 1;
            transition: transform 0.1s;
            user-select: none;
            font-weight: 900;
        }
        .white { color: #f9f9f9; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); }
        .black { color: #333333; text-shadow: 1px 1px 3px rgba(255,255,255,0.5); }

        /* Potential Move Indicator (Dot) */
        .potential-move::after {
            content: '';
            position: absolute;
            width: 25%;
            height: 25%;
            border-radius: 50%;
            background-color: var(--potential-move);
            pointer-events: none;
            z-index: 10;
        }

        /* Capture Indicator (Thicker border) */
        .potential-capture {
            box-shadow: inset 0 0 0 5px #ff3b30; /* Vivid Red border for captures */
            border-radius: 8px;
        }

        /* Custom Dropdown Styling */
        .custom-dropdown-button {
            transition: all 0.2s;
        }
        .custom-dropdown-menu {
            z-index: 50;
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
            transition: opacity 0.2s, transform 0.2s;
        }
        .custom-dropdown-menu.active {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }
    </style>
</head>
<body>

    <button id="fullscreen-button" class="absolute top-4 right-4 bg-gray-700 hover:bg-gray-600 text-white text-sm font-semibold py-2 px-4 rounded-full shadow-lg transition duration-200 z-50">
        Play Full Screen
    </button>

    <h1 class="text-4xl font-extrabold text-indigo-400 mb-6 mt-4 drop-shadow-lg">AI Chess Master</h1>

    <div id="status-message" class="text-xl font-semibold text-center rounded-xl p-4 mb-6 w-full max-w-sm md:max-w-xl bg-gray-800 text-yellow-300 shadow-2xl border border-yellow-500/50">
        Player's Turn (White)
    </div>

    <div class="main-container">
        <!-- Chess Board -->
        <div class="chess-board mr-0 md:mr-8 mb-8 md:mb-0" id="chess-board">
            <!-- Squares generated by JavaScript -->
        </div>

        <!-- Controls and History Panel -->
        <div class="flex flex-col w-full max-w-sm space-y-6">

            <!-- Control Buttons -->
            <div class="flex flex-col space-y-3">
                <button id="reset-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-xl shadow-2xl transition duration-200 transform hover:scale-[1.01] focus:outline-none focus:ring-4 focus:ring-red-500/50">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H8a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.098 7.159a5.002 5.002 0 008.892 2.193 1 1 0 01.077 1.705 7.002 7.002 0 01-12.787-3.093 1 1 0 011.818.995z" clip-rule="evenodd" /></svg>
                    Restart Game
                </button>

                <!-- Custom AI Difficulty Dropdown -->
                <div class="relative">
                    <button id="ai-dropdown-toggle" class="custom-dropdown-button flex justify-between items-center w-full bg-gray-700 text-white font-bold py-3 px-6 rounded-xl shadow-2xl transition duration-200 hover:bg-gray-600 focus:outline-none focus:ring-4 focus:ring-blue-500/50">
                        <span id="ai-difficulty-display">AI Difficulty: Medium (Depth 3)</span>
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 ml-2 transition-transform duration-200" viewBox="0 0 20 20" fill="currentColor" id="dropdown-arrow"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                    </button>

                    <div id="ai-dropdown-menu" class="custom-dropdown-menu absolute mt-2 w-full bg-gray-700 rounded-xl shadow-2xl overflow-hidden">
                        <div data-value="2" class="p-3 text-white hover:bg-indigo-500 cursor-pointer">AI Difficulty: Easy (Depth 2)</div>
                        <div data-value="3" class="p-3 text-white hover:bg-indigo-500 cursor-pointer selected bg-indigo-600">AI Difficulty: Medium (Depth 3)</div>
                        <div data-value="4" class="p-3 text-white hover:bg-indigo-500 cursor-pointer">AI Difficulty: Hard (Depth 4)</div>
                    </div>
                </div>
            </div>

            <!-- Move History Panel -->
            <div id="move-history" class="p-4 bg-gray-800 text-gray-200 rounded-xl shadow-2xl border border-gray-700 w-full h-40 overflow-y-auto">
                <h3 class="font-bold text-lg mb-2 text-indigo-400 border-b border-indigo-400/50 pb-1">Move History (PGN)</h3>
                <p id="pgn-output" class="text-sm font-mono whitespace-pre-wrap"></p>
            </div>
        </div>
    </div>


    <!-- Promotion Modal -->
    <div id="promotion-modal" class="promotion-modal hidden" aria-modal="true" role="dialog">
        <div class="promotion-options text-center">
            <h2 class="text-white text-2xl font-bold mb-4">Pawn Promotion!</h2>
            <p class="text-gray-400 mb-6">Choose a piece:</p>
            <div id="promotion-buttons" class="flex justify-center">
                <!-- Buttons will be populated here -->
            </div>
        </div>
    </div>

<script>
    // ====================================================================================
    // 1. CHESS ENGINE CORE - Constants, Piece Definitions, and Board Setup
    // ====================================================================================

    // Piece definitions using Unicode
    const PIECES = {
        'K': { code: '♔', value: 1000, color: 'white' }, 'Q': { code: '♕', value: 9, color: 'white' },
        'R': { code: '♖', value: 5, color: 'white' }, 'B': { code: '♗', value: 3.2, color: 'white' },
        'N': { code: '♘', value: 3, color: 'white' }, 'P': { code: '♙', value: 1, color: 'white' },
        'k': { code: '♚', value: -1000, color: 'black' }, 'q': { code: '♛', value: -9, color: 'black' },
        'r': { code: '♜', value: -5, color: 'black' }, 'b': { code: '♝', value: -3.2, color: 'black' },
        'n': { code: '♞', value: -3, color: 'black' }, 'p': { code: '♟', value: -1, color: 'black' },
        '.': { code: '', value: 0, color: 'empty' }
    };

    const STARTING_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

    let GameState = {
        board: [], turn: 'w', castling: 'KQkq', enPassant: '-', halfMoveClock: 0,
        fullMoveNumber: 1, selectedSquare: null, possibleMoves: [], isGameOver: false,
        history: [], aiDepth: 3, promotionPending: null,
    };

    const DIRECTIONS = [
        [0, 1], [0, -1], [1, 0], [-1, 0], // Rook/Queen
        [1, 1], [1, -1], [-1, 1], [-1, -1] // Bishop/Queen
    ];
    const KNIGHT_MOVES = [
        [2, 1], [2, -1], [-2, 1], [-2, -1],
        [1, 2], [1, -2], [-1, 2], [-1, -2]
    ];

    /** Converts a square name (e.g., 'a1') to [row, col] (e.g., [7, 0]). */
    function algebraicToCoord(sq) {
        if (sq === '-') return null;
        const col = sq.charCodeAt(0) - 'a'.charCodeAt(0);
        const row = 8 - parseInt(sq[1], 10);
        return [row, col];
    }

    /** Converts coordinates [row, col] to a square name (e.g., 'e4'). */
    function coordToAlgebraic([r, c]) {
        if (r < 0 || r > 7 || c < 0 || c > 7) return null;
        const file = String.fromCharCode('a'.charCodeAt(0) + c);
        const rank = 8 - r;
        return file + rank;
    }

    /** Parses a FEN string and sets up the game state. */
    function parseFEN(fen) {
        const parts = fen.split(' ');
        const [pieces, turn, castling, enPassant, halfMoveClock, fullMoveNumber] = parts;
        const newBoard = Array(8).fill(0).map(() => Array(8).fill('.'));
        let r = 0, c = 0;
        for (const char of pieces) {
            if (char === '/') { r++; c = 0; }
            else if (/[1-8]/.test(char)) { c += parseInt(char, 10); }
            else { newBoard[r][c] = char; c++; }
        }
        GameState.board = newBoard;
        GameState.turn = turn;
        GameState.castling = castling;
        GameState.enPassant = enPassant;
        GameState.halfMoveClock = parseInt(halfMoveClock, 10);
        GameState.fullMoveNumber = parseInt(fullMoveNumber, 10);
        GameState.isGameOver = false;
        GameState.selectedSquare = null;
        GameState.possibleMoves = [];
        GameState.promotionPending = null;
    }

    // ====================================================================================
    // 2. UI RENDERER AND DROPDOWN LOGIC
    // ====================================================================================

    const boardEl = document.getElementById('chess-board');
    const statusEl = document.getElementById('status-message');
    const pgnEl = document.getElementById('pgn-output');
    const promotionModal = document.getElementById('promotion-modal');
    const promotionButtons = document.getElementById('promotion-buttons');

    const dropdownToggle = document.getElementById('ai-dropdown-toggle');
    const dropdownMenu = document.getElementById('ai-dropdown-menu');
    const difficultyDisplay = document.getElementById('ai-difficulty-display');
    const dropdownArrow = document.getElementById('dropdown-arrow');

    // Custom Dropdown Logic
    dropdownToggle.addEventListener('click', () => {
        dropdownMenu.classList.toggle('active');
        dropdownArrow.classList.toggle('rotate-180');
    });

    dropdownMenu.querySelectorAll('div').forEach(option => {
        option.addEventListener('click', () => {
            const depth = parseInt(option.dataset.value);
            GameState.aiDepth = depth;
            difficultyDisplay.textContent = option.textContent;

            // Update selection visuals
            dropdownMenu.querySelectorAll('div').forEach(o => o.classList.remove('bg-indigo-600', 'selected'));
            option.classList.add('bg-indigo-600', 'selected');

            dropdownMenu.classList.remove('active');
            dropdownArrow.classList.remove('rotate-180');

            console.log(`AI depth set to ${GameState.aiDepth}`);
        });
    });

    // Close dropdown if user clicks outside
    document.addEventListener('click', (e) => {
        if (!dropdownToggle.contains(e.target) && !dropdownMenu.contains(e.target)) {
            dropdownMenu.classList.remove('active');
            dropdownArrow.classList.remove('rotate-180');
        }
    });

    /** Renders the entire chess board and its pieces to the DOM. */
    function renderBoard() {
        boardEl.innerHTML = '';
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const squareEl = document.createElement('div');
                squareEl.className = 'square rounded-sm transition-all duration-100 ease-in-out';
                squareEl.dataset.row = r;
                squareEl.dataset.col = c;
                squareEl.id = `sq-${r}-${c}`;
                const color = (r + c) % 2 === 0 ? 'light' : 'dark';
                squareEl.classList.add(color);

                const pieceChar = GameState.board[r][c];
                if (pieceChar !== '.') {
                    const pieceData = PIECES[pieceChar];
                    const pieceEl = document.createElement('span');
                    pieceEl.className = `piece ${pieceData.color}`;
                    pieceEl.textContent = pieceData.code;
                    pieceEl.dataset.piece = pieceChar;
                    squareEl.appendChild(pieceEl);
                }
                squareEl.addEventListener('click', handleSquareClick);
                boardEl.appendChild(squareEl);
            }
        }
        updateUIState();
    }

    /** Updates the UI based on the current GameState. */
    function updateUIState() {
        document.querySelectorAll('.square').forEach(sq => {
            sq.classList.remove('selected', 'potential-move', 'potential-capture');
        });

        if (GameState.selectedSquare) {
            const [r, c] = GameState.selectedSquare;
            document.getElementById(`sq-${r}-${c}`).classList.add('selected');

            GameState.possibleMoves.forEach(move => {
                const [tr, tc] = move.to;
                const targetSquareEl = document.getElementById(`sq-${tr}-${tc}`);
                const targetPiece = GameState.board[tr][tc];

                if (targetPiece !== '.') {
                    targetSquareEl.classList.add('potential-capture');
                } else {
                    targetSquareEl.classList.add('potential-move');
                }
            });
        }

        // Update Status
        if (GameState.isGameOver) {
            const result = isGameOver(GameState.board, GameState.turn, GameState.halfMoveClock);
            if (result.checkmate) {
                const winner = GameState.turn === 'w' ? 'Black' : 'White';
                statusEl.textContent = `Checkmate! ${winner} Wins!`;
                statusEl.classList.remove('text-yellow-300', 'bg-gray-700');
                statusEl.classList.add('bg-red-800', 'text-white', 'border-red-500/50');
            } else if (result.stalemate || result.fiftyMove) {
                statusEl.textContent = "Draw! Game Over by Stalemate or Fifty-Move Rule.";
                statusEl.classList.remove('text-yellow-300', 'bg-gray-700');
                statusEl.classList.add('bg-blue-800', 'text-white', 'border-blue-500/50');
            }
        } else {
            statusEl.textContent = `${GameState.turn === 'w' ? "Player (White)" : "AI (Black)"}'s Turn`;
            const inCheck = isKingInCheck(GameState.board, GameState.turn);
            if (inCheck) {
                statusEl.textContent = `${GameState.turn === 'w' ? "Player (White)" : "AI (Black)"} is in Check!`;
            }
            statusEl.classList.remove('bg-red-800', 'bg-blue-800', 'text-white', 'border-red-500/50', 'border-blue-500/50');
            statusEl.classList.add('bg-gray-800', 'text-yellow-300', 'border-yellow-500/50');
        }

        // Update PGN
        pgnEl.textContent = GameState.history.join(' ');
    }

    /** Shows the pawn promotion modal. */
    function showPromotionModal(pendingMove) {
        GameState.promotionPending = pendingMove;
        promotionButtons.innerHTML = '';
        const pieces = GameState.turn === 'w' ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];

        pieces.forEach(pieceChar => {
            const btn = document.createElement('button');
            btn.className = 'promotion-option';
            btn.textContent = PIECES[pieceChar].code;
            btn.addEventListener('click', () => handlePromotion(pieceChar));
            promotionButtons.appendChild(btn);
        });

        promotionModal.classList.remove('hidden');
    }

    // ====================================================================================
    // 3. MOVE GENERATOR & GAME LOGIC
    // ====================================================================================

    /** Generates all pseudo-legal moves for a given piece on the board. */
    function generatePieceMoves(board, r, c) {
        // ... (Logic remains largely the same as before) ...
        const moves = [];
        const pieceChar = board[r][c];
        const isWhite = pieceChar === pieceChar.toUpperCase();
        const opponentColor = isWhite ? 'black' : 'white';
        const pieceType = pieceChar.toLowerCase();

        const isCoordValid = (r, c) => r >= 0 && r < 8 && c >= 0 && c < 8;
        const isTargetEmptyOrOpponent = (r, c) => {
            const target = board[r][c];
            if (target === '.') return true;
            return PIECES[target].color === opponentColor;
        };

        const addMove = (r2, c2, promotion = null) => moves.push({ from: [r, c], to: [r2, c2], promotion });

        switch (pieceType) {
            case 'p': // PAWN
                const dir = isWhite ? -1 : 1;
                const startRow = isWhite ? 6 : 1;
                const promRow = isWhite ? 0 : 7;

                // 1. Single Step Forward
                const r1 = r + dir;
                if (isCoordValid(r1, c) && board[r1][c] === '.') {
                    if (r1 === promRow) {
                        ['Q', 'R', 'B', 'N'].forEach(p => addMove(r1, c, isWhite ? p : p.toLowerCase()));
                    } else {
                        addMove(r1, c);
                    }
                    // 2. Double Step Forward
                    const r2 = r + 2 * dir;
                    if (r === startRow && isCoordValid(r2, c) && board[r2][c] === '.') {
                        addMove(r2, c);
                    }
                }

                // 3. Captures
                [-1, 1].forEach(colOffset => {
                    const c2 = c + colOffset;
                    if (isCoordValid(r1, c2)) {
                        const target = board[r1][c2];
                        // Normal capture
                        if (target !== '.' && PIECES[target].color === opponentColor) {
                            if (r1 === promRow) {
                                ['Q', 'R', 'B', 'N'].forEach(p => addMove(r1, c2, isWhite ? p : p.toLowerCase()));
                            } else {
                                addMove(r1, c2);
                            }
                        }
                        // En Passant capture
                        if (GameState.enPassant !== '-') {
                            const [ep_r, ep_c] = algebraicToCoord(GameState.enPassant);
                            if (r1 === ep_r && c2 === ep_c) {
                                addMove(r1, c2);
                            }
                        }
                    }
                });
                break;

            case 'n': // KNIGHT
                KNIGHT_MOVES.forEach(([dr, dc]) => {
                    const r2 = r + dr;
                    const c2 = c + dc;
                    if (isCoordValid(r2, c2) && isTargetEmptyOrOpponent(r2, c2)) {
                        addMove(r2, c2);
                    }
                });
                break;

            case 'b': // BISHOP
            case 'r': // ROOK
            case 'q': // QUEEN
                const startDir = pieceType === 'r' ? 0 : (pieceType === 'b' ? 4 : 0);
                const endDir = pieceType === 'r' ? 4 : (pieceType === 'b' ? 8 : 8);

                for (let i = startDir; i < endDir; i++) {
                    const [dr, dc] = DIRECTIONS[i];
                    for (let step = 1; step < 8; step++) {
                        const r2 = r + dr * step;
                        const c2 = c + dc * step;

                        if (!isCoordValid(r2, c2)) break;

                        const target = board[r2][c2];
                        const isOpponent = target !== '.' && PIECES[target].color === opponentColor;
                        const isEmpty = target === '.';

                        if (isEmpty) {
                            addMove(r2, c2);
                        } else if (isOpponent) {
                            addMove(r2, c2);
                            break;
                        } else {
                            break;
                        }
                    }
                }
                break;

            case 'k': // KING
                for (let i = 0; i < 8; i++) {
                    const [dr, dc] = DIRECTIONS[i];
                    const r2 = r + dr;
                    const c2 = c + dc;
                    if (isCoordValid(r2, c2) && isTargetEmptyOrOpponent(r2, c2)) {
                        addMove(r2, c2);
                    }
                }

                // Castling
                if (pieceType === 'k' && r === (isWhite ? 7 : 0) && c === 4) {
                    const opponent = opponentColor;
                    const castlingRights = GameState.castling;
                    const homeRow = isWhite ? 7 : 0;

                    // Kingside (short) castling
                    const kSide = isWhite ? 'K' : 'k';
                    if (castlingRights.includes(kSide) && board[homeRow][5] === '.' && board[homeRow][6] === '.') {
                        if (!isSquareAttacked(board, homeRow, 4, opponent) &&
                            !isSquareAttacked(board, homeRow, 5, opponent) &&
                            !isSquareAttacked(board, homeRow, 6, opponent)) {
                            addMove(homeRow, 6);
                        }
                    }
                    // Queenside (long) castling
                    const qSide = isWhite ? 'Q' : 'q';
                    if (castlingRights.includes(qSide) && board[homeRow][3] === '.' && board[homeRow][2] === '.' && board[homeRow][1] === '.') {
                        if (!isSquareAttacked(board, homeRow, 4, opponent) &&
                            !isSquareAttacked(board, homeRow, 3, opponent) &&
                            !isSquareAttacked(board, homeRow, 2, opponent)) {
                            addMove(homeRow, 2);
                        }
                    }
                }
                break;
        }

        return moves;
    }

    /** Determines if a given square is attacked by the opponent. */
    function isSquareAttacked(board, r, c, attackerColor) {
        const isAttackerWhite = attackerColor === 'white';
        const attackerPieces = isAttackerWhite ? 'KQRNBP' : 'kqrbnp';

        for (let r_s = 0; r_s < 8; r_s++) {
            for (let c_s = 0; c_s < 8; c_s++) {
                const piece = board[r_s][c_s];
                if (attackerPieces.includes(piece)) {
                    const pseudoMoves = generatePieceMoves(board, r_s, c_s).filter(m => !m.promotion);

                    for (const move of pseudoMoves) {
                        if (move.to[0] === r && move.to[1] === c) {
                            // Pawns attack diagonally, King attacks all around, others don't matter as much.
                            if (piece.toLowerCase() === 'p') {
                                if (Math.abs(c_s - c) === 1) return true;
                            } else if (piece.toLowerCase() === 'k') {
                                if (Math.abs(r_s - r) <= 1 && Math.abs(c_s - c) <= 1) return true;
                            } else {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    /** Finds the king's position for the given color. */
    function findKing(board, color) {
        const kingChar = color === 'w' ? 'K' : 'k';
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (board[r][c] === kingChar) return [r, c];
            }
        }
        return null;
    }

    /** Checks if the current side's king is in check. */
    function isKingInCheck(board, color) {
        const kingPos = findKing(board, color);
        if (!kingPos) return false;
        const attackerColor = color === 'w' ? 'black' : 'white';
        return isSquareAttacked(board, kingPos[0], kingPos[1], attackerColor);
    }

    /** Generates all legal moves for the current side. */
    function generateLegalMoves(board, turn) {
        const legalMoves = [];
        const playerPieces = turn === 'w' ? 'KQRNBP' : 'kqrbnp';

        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const pieceChar = board[r][c];
                if (playerPieces.includes(pieceChar)) {
                    const pseudoMoves = generatePieceMoves(board, r, c);
                    for (const move of pseudoMoves) {
                        const nextState = makeMove(board, move, GameState.castling, GameState.enPassant, GameState.halfMoveClock);
                        if (!isKingInCheck(nextState.board, turn)) {
                            legalMoves.push(move);
                        }
                    }
                }
            }
        }
        return legalMoves;
    }

    /**
     * Executes a move on a given board state and returns the new board/state.
     * Takes current GameState properties as args to keep it a pure function.
     */
    function makeMove(currentBoard, move, currentCastling, currentEnPassant, currentHalfMove) {
        const newBoard = currentBoard.map(row => [...row]);
        const [r1, c1] = move.from;
        const [r2, c2] = move.to;
        const pieceChar = newBoard[r1][c1];
        const pieceType = pieceChar.toLowerCase();
        const isWhite = pieceChar === pieceChar.toUpperCase();

        let newCastling = currentCastling;
        let newEnPassant = '-';
        let newHalfMove = currentHalfMove;
        const isCapture = newBoard[r2][c2] !== '.';

        // 1. Move the piece
        newBoard[r2][c2] = move.promotion || pieceChar;
        newBoard[r1][c1] = '.';

        // 2. Clock updates
        if (pieceType === 'p' || isCapture) {
            newHalfMove = 0;
        } else {
            newHalfMove++;
        }

        // 3. Special move details
        if (pieceType === 'p') {
            // En Passant target update
            if (Math.abs(r1 - r2) === 2) {
                newEnPassant = coordToAlgebraic([r1 + (isWhite ? -1 : 1), c1]);
            }
            // En Passant capture (remove the captured pawn)
            else if (isCapture && coordToAlgebraic(move.to) === currentEnPassant) {
                const capturedPawnRow = isWhite ? r2 + 1 : r2 - 1;
                newBoard[capturedPawnRow][c2] = '.';
            }
        }

        // Castling (Rook movement)
        if (pieceType === 'k' && Math.abs(c1 - c2) === 2) {
            const homeRow = isWhite ? 7 : 0;
            // Kingside (short: King moves e->g, Rook moves h->f)
            if (c2 === 6) { newBoard[homeRow][5] = newBoard[homeRow][7]; newBoard[homeRow][7] = '.'; }
            // Queenside (long: King moves e->c, Rook moves a->d)
            else if (c2 === 2) { newBoard[homeRow][3] = newBoard[homeRow][0]; newBoard[homeRow][0] = '.'; }
        }

        // 4. Castling rights update (Fix: Includes capture of a rook)
        if (pieceChar === 'K') newCastling = newCastling.replace(/[KQ]/g, '');
        if (pieceChar === 'k') newCastling = newCastling.replace(/[kq]/g, '');

        // Rook moves/captures from starting squares
        if (r1 === 7 && c1 === 7) newCastling = newCastling.replace('K', ''); // White Kingside Rook moves
        if (r1 === 7 && c1 === 0) newCastling = newCastling.replace('Q', ''); // White Queenside Rook moves
        if (r1 === 0 && c1 === 7) newCastling = newCastling.replace('k', ''); // Black Kingside Rook moves
        if (r1 === 0 && c1 === 0) newCastling = newCastling.replace('q', ''); // Black Queenside Rook moves

        // If a rook is captured on its starting square
        const targetSq = coordToAlgebraic(move.to);
        if (targetSq === 'a8') newCastling = newCastling.replace('q', '');
        if (targetSq === 'h8') newCastling = newCastling.replace('k', '');
        if (targetSq === 'a1') newCastling = newCastling.replace('Q', '');
        if (targetSq === 'h1') newCastling = newCastling.replace('K', '');

        return {
            board: newBoard, enPassant: newEnPassant, castling: newCastling, halfMoveClock: newHalfMove
        };
    }

    /** Checks for checkmate, stalemate, and draw conditions. */
    function isGameOver(board, turn, halfMoveClock) {
        const legalMoves = generateLegalMoves(board, turn);
        const inCheck = isKingInCheck(board, turn);
        const hasMoves = legalMoves.length > 0;

        return {
            checkmate: inCheck && !hasMoves,
            stalemate: !inCheck && !hasMoves,
            fiftyMove: halfMoveClock >= 100
        };
    }

    /** Converts a move object into simplified PGN notation. */
    function generatePGN(move, oldBoard, newBoard, isCheckmate) {
        const [r1, c1] = move.from;
        const [r2, c2] = move.to;
        const pieceChar = oldBoard[r1][c1];
        const pieceType = pieceChar.toUpperCase();
        const fromSq = coordToAlgebraic(move.from);
        const toSq = coordToAlgebraic(move.to);
        const isCapture = newBoard[r2][c2] !== pieceChar; // Capture includes replacing piece or EP
        const checkSuffix = isCheckmate ? '#' : (isKingInCheck(newBoard, GameState.turn === 'w' ? 'b' : 'w') ? '+' : '');

        // 1. Castling
        if (pieceType === 'K' && Math.abs(c1 - c2) === 2) {
            return c2 === 6 ? `O-O${checkSuffix}` : `O-O-O${checkSuffix}`;
        }

        let pgn = '';

        // 2. Piece Initial (or none for Pawn)
        if (pieceType !== 'P') pgn += pieceType;

        // 3. Capture
        if (isCapture) {
            // For pawn captures, include the file of origin
            if (pieceType === 'P') pgn += fromSq[0];
            pgn += 'x';
        }

        // 4. Destination
        pgn += toSq;

        // 5. Promotion
        if (move.promotion) pgn += `=${move.promotion.toUpperCase()}`;

        // 6. Check/Checkmate
        pgn += checkSuffix;

        return pgn;
    }


    // ====================================================================================
    // 4. USER INTERACTION & GAME FLOW
    // ====================================================================================

    /** Main handler for user clicks on a square. */
    function handleSquareClick(event) {
        if (GameState.turn !== 'w' || GameState.isGameOver || GameState.promotionPending) return;

        const targetEl = event.currentTarget;
        const r = parseInt(targetEl.dataset.row);
        const c = parseInt(targetEl.dataset.col);
        const pieceChar = GameState.board[r][c];
        const isWhitePiece = pieceChar !== '.' && pieceChar === pieceChar.toUpperCase();

        if (GameState.selectedSquare === null) {
            if (isWhitePiece) {
                GameState.selectedSquare = [r, c];
                GameState.possibleMoves = generateLegalMoves(GameState.board, 'w');
                GameState.possibleMoves = GameState.possibleMoves.filter(m => m.from[0] === r && m.from[1] === c);
            }
        } else {
            const [r_from, c_from] = GameState.selectedSquare;
            const move = GameState.possibleMoves.find(m => m.to[0] === r && m.to[1] === c);

            if (move) {
                if (move.promotion) {
                    showPromotionModal(move);
                } else {
                    executeMove(move);
                }
            } else if (isWhitePiece && r === r_from && c === c_from) {
                GameState.selectedSquare = null;
                GameState.possibleMoves = [];
            } else if (isWhitePiece) {
                GameState.selectedSquare = [r, c];
                GameState.possibleMoves = generateLegalMoves(GameState.board, 'w').filter(m => m.from[0] === r && m.from[1] === c);
            } else {
                GameState.selectedSquare = null;
                GameState.possibleMoves = [];
            }
        }
        updateUIState();
    }

    /** Handles the pawn promotion choice and completes the move. */
    function handlePromotion(pieceChar) {
        if (GameState.promotionPending) {
            const move = GameState.promotionPending;
            move.promotion = pieceChar;
            executeMove(move);
            promotionModal.classList.add('hidden');
            GameState.promotionPending = null;
        }
    }

    /** Updates the full GameState based on a completed move. */
    function executeMove(move) {
        if (GameState.isGameOver) return;

        const oldBoard = GameState.board;
        const newState = makeMove(oldBoard, move, GameState.castling, GameState.enPassant, GameState.halfMoveClock);

        // Check for checkmate/check in the NEW state *after* the move is made
        const nextTurn = GameState.turn === 'w' ? 'b' : 'w';
        const result = isGameOver(newState.board, nextTurn, newState.halfMoveClock);
        const pgnMove = generatePGN(move, oldBoard, newState.board, result.checkmate);

        if (GameState.turn === 'w') GameState.history.push(`${GameState.fullMoveNumber}. ${pgnMove}`);
        else GameState.history[GameState.history.length - 1] += ` ${pgnMove}`;

        // Update global state
        GameState.board = newState.board;
        GameState.castling = newState.castling;
        GameState.enPassant = newState.enPassant;
        GameState.halfMoveClock = newState.halfMoveClock;

        if (GameState.turn === 'b') { GameState.fullMoveNumber++; }
        GameState.turn = nextTurn;
        GameState.selectedSquare = null;
        GameState.possibleMoves = [];
        GameState.isGameOver = result.checkmate || result.stalemate || result.fiftyMove;

        renderBoard();

        // If it's the AI's turn, trigger the AI move
        if (GameState.turn === 'b' && !GameState.isGameOver) {
            setTimeout(triggerAIMove, 500);
        }
    }

    // ====================================================================================
    // 5. AI ENGINE (Minimax with Alpha-Beta Pruning)
    // ====================================================================================

    /** Evaluation function (Material + simple Positional) */
    function evaluateBoard(board) {
        let score = 0;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const pieceChar = board[r][c];
                if (pieceChar !== '.') {
                    score += PIECES[pieceChar].value;
                }
            }
        }
        // Positional bonus for central pawns
        for (let r = 1; r < 7; r++) {
            for (let c = 3; c < 5; c++) {
                const pieceChar = board[r][c];
                if (pieceChar === 'P') score += 0.05 * (8 - r);
                if (pieceChar === 'p') score -= 0.05 * r;
            }
        }
        return score;
    }

    /** Minimax algorithm with Alpha-Beta Pruning. */
    function minimax(board, turn, depth, alpha, beta, gameState) {
        if (depth === 0) {
            return evaluateBoard(board);
        }

        const legalMoves = generateLegalMoves(board, turn);
        const gameOver = isGameOver(board, turn, gameState.halfMoveClock);

        if (gameOver.checkmate) { return turn === 'w' ? -Infinity - depth : Infinity + depth; }
        if (gameOver.stalemate || gameOver.fiftyMove) { return 0; }
        if (legalMoves.length === 0) { return 0; } // Should be covered by stalemate, but safe guard

        const nextTurn = turn === 'w' ? 'b' : 'w';

        if (turn === 'w') { // Maximizing player (White)
            let maxEval = -Infinity;
            for (const move of legalMoves) {
                const newState = makeMove(board, move, gameState.castling, gameState.enPassant, gameState.halfMoveClock);
                const evaluation = minimax(newState.board, nextTurn, depth - 1, alpha, beta, newState);
                maxEval = Math.max(maxEval, evaluation);
                alpha = Math.max(alpha, evaluation);
                if (beta <= alpha) break;
            }
            return maxEval;
        } else { // Minimizing player (Black/AI)
            let minEval = Infinity;
            for (const move of legalMoves) {
                const newState = makeMove(board, move, gameState.castling, gameState.enPassant, gameState.halfMoveClock);
                const evaluation = minimax(newState.board, nextTurn, depth - 1, alpha, beta, newState);
                minEval = Math.min(minEval, evaluation);
                beta = Math.min(beta, evaluation);
                if (beta <= alpha) break;
            }
            return minEval;
        }
    }

    /** Finds the best move for the AI using the Minimax algorithm. */
    function triggerAIMove() {
        statusEl.textContent = `AI (Black) is thinking... (Depth ${GameState.aiDepth})`;
        statusEl.classList.add('bg-blue-600', 'text-white', 'border-blue-500/50');
        statusEl.classList.remove('bg-gray-800', 'text-yellow-300', 'border-yellow-500/50');

        // Since we are running in the main thread, we use a setTimeout of 0 to yield execution
        // which prevents the UI from freezing, even if the calculation is still synchronous.
        setTimeout(() => {
            const bestMove = findBestAIMove(GameState.board, GameState.turn, GameState.aiDepth, GameState);

            statusEl.classList.remove('bg-blue-600', 'text-white', 'border-blue-500/50');

            if (bestMove) {
                executeMove(bestMove);
            } else {
                console.warn("AI could not find a move. Game likely over.");
                updateUIState(); // Force a final UI update
            }
        }, 0); // Execute search after UI has updated
    }

    /** Iterates through all legal moves and uses Minimax to find the highest-scoring move. */
    function findBestAIMove(board, turn, depth, gameState) {
        const legalMoves = generateLegalMoves(board, turn);
        let bestMove = null;
        let minEval = Infinity;

        // Shuffle moves to introduce randomness for equally good moves
        legalMoves.sort(() => Math.random() - 0.5);

        for (const move of legalMoves) {
            const newState = makeMove(board, move, gameState.castling, gameState.enPassant, gameState.halfMoveClock);
            const evaluation = minimax(newState.board, 'w', depth - 1, -Infinity, Infinity, newState);

            if (evaluation < minEval) {
                minEval = evaluation;
                bestMove = move;
            }
        }
        return bestMove;
    }

    // ====================================================================================
    // 6. INITIALIZATION & EVENT LISTENERS
    // ====================================================================================

    function initializeGame() {
        parseFEN(STARTING_FEN);
        GameState.history = [];
        // Ensure AI depth is correctly initialized from the selected option
        const selectedOption = dropdownMenu.querySelector('.selected');
        GameState.aiDepth = selectedOption ? parseInt(selectedOption.dataset.value) : 3;
        renderBoard();
    }

    // Reset button
    document.getElementById('reset-button').addEventListener('click', initializeGame);

    // Fullscreen button logic
    document.getElementById('fullscreen-button').addEventListener('click', () => {
        // As requested, opens a new blank tab. On a hosted site, this would open the game URL.
        window.open(window.location.href, '_blank');
    });

    // Start the game when the script loads
    window.onload = initializeGame;

</script>
</body>
</html>

